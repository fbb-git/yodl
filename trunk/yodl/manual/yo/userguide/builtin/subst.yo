tt(SUBST) is a general-purpose substitution mechanism for strings in the
input. tt(SUBST) takes two arguments: a search string and a substitution
string.  E.g., after
        verb(
    SUBST(VERSION)(1.00)
        ) 
    YODL will transorm all occurrences of tt(VERSION) in its input into 
tt(1.00).

    tt(SUBST) is also useful in situations where multi-character
sequences should be converted to accent characters. E.g., a LaTeX() converter
might define:
        verb(
    SUBST('e)(NOTRANS(\'{e}))
        )
    Each tt('e) in the input will then be converted to tt(\'e). 

    tt(SUBST) may be useed in combination with the command line 
flag tt(-P), as in a invocation
        verb(
    yodl2html -P'SUBST(VERSION)(1.00)' myfile.yo
        )

Another useful substitution might be:
        verb(
    SUBST(_OP_)(CHAR(C)HAR(40))
    SUBST(_CP_)(CHAR(C)HAR(41))
        )

which defines an opening parenthesis (tt(_OP_)) and a closing parenthesis 
(tt(_CP_)) as mapped to the tt(CHAR) function. The strings tt(_OP_) and tt(_CP_) 
might then be used to produce unbalanced parameter lists.

Note that:
    itemization(
    it() The first argument of the tt(SUBST) command, the search string, is
taken literally. Yodl does not expand it; the string must be literally
matched in the input.
    it() The second argument, the replacement, is further processed by Yodl. 
Protect this text by tt(NOTRANS) or tt(NOEXPAND) where appropriate.
    )

Substitutions occur extremely early while YODL processes its input files. In
order to processs its input files, YODL takes the following basic steps:
    enumeration(
    eit() It requests input from its lexical scanner (so-called em(tokens))
    eit() Its parser processes the tokens produced by the lexical scanner
    eit() Its parser may send text to an output `object', which will
eventually appear in the output file generated by YODL.
    )
    YODL will perform all macro substitutions in step 2, and all character
table conversions in step 3. However, the lexical scanner has access to the
tt(SUBST) definitions: as soon as its lexical analyzer detects a series of
characters matching the defining sequence of a tt(SUBST) definition, it will
replace that defining sequence by its definition. That definition is then
again read by the lexical scanner. Of course, this definition may, in turn,
contain defining sequences of other tt(SUBST) definitions: these will then be
replaced by their definitions as well. This implies:
    itemization(
    it() Circular definitions may cause the lexical scanner to get stuck in a
replacement loop. It is the responsibility of the author defining tt(SUBST)
definitions to make sure that this doesn't happen.
    it() Neither the parser, nor the output object ever sees the tt(SUBST)
defining character sequences: they will only see their definitions.
    )









